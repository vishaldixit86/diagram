#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
app_perm_compare.py

Build SHOULD-HAVE vs DOES-HAVE comparison for Application + Permission.

Primary API:
    build_app_perm_should_vs_does_report(...)

Optional CLI:
    python app_perm_compare.py --shd-have "..." --hr "..." --does-have "..." --out "output.xlsx" [other args]

Author: Generated by ChatGPT
"""

import re
import argparse
from typing import Any, Dict, List, Optional, Tuple
import pandas as pd


def build_app_perm_should_vs_does_report(
    shd_have_xlsx: str,
    hr_xlsx: str,
    does_have_access_file: str,
    out_xlsx: Optional[str] = None,
    # ---------- SHOULD HAVE ----------
    shd_sheet_filter_contains: Optional[str] = None,   # e.g. "COOPAL" or None for all sheets
    shd_keep_cols: Tuple[str, ...] = (
        "SOURCE",
        "PERSONA",
        "UPDATED APPLICATION NAME",
        "APPLICATION NAME",
        "NEEDED FOR PERSONA?",
        "ASSET TYPE",
        "ENTITLEMENTS",
        "PERMISSION",
    ),
    shd_persona_col: str = "PERSONA",
    shd_app_col_candidates: Tuple[str, ...] = ("UPDATED APPLICATION NAME", "APPLICATION NAME", "APP", "APPLICATION"),
    shd_perm_col_candidates: Tuple[str, ...] = ("PERMISSION", "ENTITLEMENTS", "APP PERMISSION", "PRIVILEGE"),
    # ---------- HR / PERSONA MAP ----------
    hr_costcenter_col: str = "COST CENTER - ID",
    hr_mgmt_level_col: str = "MANAGEMENT LEVEL",
    hr_persona_out_col: str = "SUGGESTED PERSONA",
    # optional mapping file (same pattern you used earlier)
    costcenter_persona_map_xlsx: Optional[str] = None,
    costcenter_persona_map_sheet: Optional[str] = None,
    map_costcenter_col: str = "COSTCENTER_MANAGEMENT-LEVEL",
    map_persona_col: str = "PERSONA",
    # ---------- DOES HAVE ----------
    does_have_brid_col: str = "BRID",
    does_have_app_col_candidates: Tuple[str, ...] = ("APPLICATION", "APP", "APP_NAME", "APPLICATION NAME"),
    does_have_perm_col_candidates: Tuple[str, ...] = ("PERMISSION", "ENTITLEMENT", "PRIVILEGE", "ROLE", "ACCESS"),
    does_have_delimiter: str = "|",
    # ---------- MATCHING BEHAVIOR ----------
    app_norm_upper: bool = True,
    perm_norm_upper: bool = True,
) -> pd.DataFrame:
    """
    Builds SHOULD-HAVE vs DOES-HAVE comparison for Application + Permission.

    Output columns per HR row:
      - SHD_HAVE_APP_PERM_SET
      - DOES_HAVE_APP_PERM_SET
      - MATCHED_APP_PERM
      - MISSING_APP_PERM
      - EXCESS_APP_PERM

    Notes:
      - SHOULD-HAVE key is PERSONA (from mapping or HR)
      - DOES-HAVE key is BRID (from HR)
      - Each token looks like: "APP_NAME :: PERMISSION"
    """

    # ---------------- helpers ----------------
    def _upper_strip_cols(df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()
        df.columns = [str(c).strip().upper() for c in df.columns]
        return df

    def _safe_str(x: Any) -> str:
        if x is None or (isinstance(x, float) and pd.isna(x)):
            return ""
        return str(x)

    def _norm_space(s: str) -> str:
        s = s.strip()
        s = re.sub(r"\s+", " ", s)
        return s

    def _norm_app(x: Any) -> str:
        s = _norm_space(_safe_str(x))
        return s.upper() if app_norm_upper else s

    def _norm_perm(x: Any) -> str:
        s = _norm_space(_safe_str(x))
        return s.upper() if perm_norm_upper else s

    def _pick_first_existing(df_cols: List[str], candidates: Tuple[str, ...]) -> Optional[str]:
        df_cols_u = [c.upper() for c in df_cols]
        for c in candidates:
            if c.upper() in df_cols_u:
                return c.upper()
        return None

    def _split_multi_values(cell: Any) -> List[str]:
        """
        Split a cell into multiple permissions if it contains lists like:
        newline, comma, semicolon, pipe separated.
        """
        s = _safe_str(cell)
        if not s.strip():
            return []
        parts = re.split(r"[\n\r,;|]+", s)
        return [p for p in (p.strip() for p in parts) if p]

    def _app_perm_token(app: Any, perm: Any) -> str:
        a = _norm_app(app)
        p = _norm_perm(perm)
        if not a and not p:
            return ""
        if a and p:
            return f"{a} :: {p}"
        # allow app-only if permission missing
        return a if a else f"UNKNOWN_APP :: {p}"

    def _to_app_perm_set_by_key(df: pd.DataFrame, key_col: str, app_col: str, perm_col: str) -> Dict[str, set]:
        """
        Creates dictionary:
          key -> set(APP::PERM)
        """
        d: Dict[str, set] = {}
        tmp = df[[key_col, app_col, perm_col]].dropna(subset=[key_col]).copy()
        for k, sub in tmp.groupby(key_col):
            s = set()
            for _, r in sub.iterrows():
                app_val = r.get(app_col, "")
                perm_val = r.get(perm_col, "")
                perms = _split_multi_values(perm_val) if _safe_str(perm_val).strip() else [""]
                for pv in perms:
                    tok = _app_perm_token(app_val, pv)
                    if tok:
                        s.add(tok)
            d[str(k)] = s
        return d

    def _compare_sets(does_set: set, shd_set: set):
        matched = sorted(list(does_set & shd_set))
        missing = sorted(list(shd_set - does_set))
        excess  = sorted(list(does_set - shd_set))
        return matched, missing, excess

    # ---------------- 1) SHOULD HAVE ----------------
    xls = pd.ExcelFile(shd_have_xlsx)
    sheet_names = xls.sheet_names
    if shd_sheet_filter_contains:
        sheet_names = [s for s in sheet_names if shd_sheet_filter_contains.upper() in s.upper()]

    shd_frames = []
    for sh in sheet_names:
        df_sh = pd.read_excel(shd_have_xlsx, sheet_name=sh)
        df_sh = _upper_strip_cols(df_sh)

        keep = [c for c in (x.upper() for x in shd_keep_cols) if c in df_sh.columns]
        if keep:
            df_sh = df_sh.loc[:, keep].copy()
        df_sh["SHEET_NAME"] = sh

        # normalize persona
        if shd_persona_col.upper() in df_sh.columns:
            df_sh[shd_persona_col.upper()] = df_sh[shd_persona_col.upper()].astype(str).map(_norm_app)

        shd_frames.append(df_sh)

    df_shd = pd.concat(shd_frames, ignore_index=True) if shd_frames else pd.DataFrame()
    df_shd = _upper_strip_cols(df_shd)

    shd_persona_col_u = shd_persona_col.upper()
    shd_app_col = _pick_first_existing(df_shd.columns.tolist(), shd_app_col_candidates)
    shd_perm_col = _pick_first_existing(df_shd.columns.tolist(), shd_perm_col_candidates)

    if not shd_app_col or not shd_perm_col or shd_persona_col_u not in df_shd.columns:
        raise ValueError(
            f"SHOULD-HAVE missing required columns. Need PERSONA + (app col from {shd_app_col_candidates}) "
            f"+ (perm col from {shd_perm_col_candidates}). Found app={shd_app_col}, perm={shd_perm_col}, "
            f"persona_present={shd_persona_col_u in df_shd.columns}"
        )

    # should-have mapping: PERSONA -> set(APP::PERM)
    shd_have_persona_to_appperm = _to_app_perm_set_by_key(
        df_shd, key_col=shd_persona_col_u, app_col=shd_app_col, perm_col=shd_perm_col
    )

    # ---------------- 2) DOES HAVE ----------------
    df_does = pd.read_csv(does_have_access_file, sep=does_have_delimiter, engine="python", dtype=str)
    df_does = _upper_strip_cols(df_does)

    brid_u = does_have_brid_col.upper()
    if brid_u in df_does.columns:
        df_does[brid_u] = df_does[brid_u].astype(str).map(_norm_app)

    does_app_col = _pick_first_existing(df_does.columns.tolist(), does_have_app_col_candidates)
    does_perm_col = _pick_first_existing(df_does.columns.tolist(), does_have_perm_col_candidates)

    if brid_u not in df_does.columns or not does_app_col or not does_perm_col:
        raise ValueError(
            f"DOES-HAVE missing required columns. Need BRID + (app col from {does_have_app_col_candidates}) "
            f"+ (perm col from {does_have_perm_col_candidates}). Found app={does_app_col}, perm={does_perm_col}, "
            f"brid_present={brid_u in df_does.columns}"
        )

    does_have_brid_to_appperm = _to_app_perm_set_by_key(
        df_does, key_col=brid_u, app_col=does_app_col, perm_col=does_perm_col
    )

    # ---------------- 3) HR + persona mapping ----------------
    df_hr = pd.read_excel(hr_xlsx)
    df_hr = _upper_strip_cols(df_hr)

    # Optional costcenter->persona mapping
    costcenter_persona_mapping: Dict[str, str] = {}
    if costcenter_persona_map_xlsx:
        map_df = (
            pd.read_excel(costcenter_persona_map_xlsx, sheet_name=costcenter_persona_map_sheet)
            if costcenter_persona_map_sheet
            else pd.read_excel(costcenter_persona_map_xlsx)
        )
        map_df = _upper_strip_cols(map_df)

        if map_costcenter_col.upper() in map_df.columns and map_persona_col.upper() in map_df.columns:
            map_df[map_costcenter_col.upper()] = map_df[map_costcenter_col.upper()].astype(str).map(_norm_app)
            map_df[map_persona_col.upper()] = map_df[map_persona_col.upper()].astype(str).map(_norm_app)
            costcenter_persona_mapping = dict(zip(map_df[map_costcenter_col.upper()], map_df[map_persona_col.upper()]))

    cc_u = hr_costcenter_col.upper()
    ml_u = hr_mgmt_level_col.upper()
    out_persona_u = hr_persona_out_col.upper()

    if cc_u in df_hr.columns and ml_u in df_hr.columns:
        df_hr["COSTCENTER_MANAGEMENT-LEVEL"] = (
            df_hr[cc_u].astype(str).str.strip() + "_" + df_hr[ml_u].astype(str).str.strip()
        ).map(_norm_app)

        if costcenter_persona_mapping:
            df_hr[out_persona_u] = df_hr["COSTCENTER_MANAGEMENT-LEVEL"].map(costcenter_persona_mapping)

    # Normalize persona
    if out_persona_u in df_hr.columns:
        df_hr[out_persona_u] = df_hr[out_persona_u].astype(str).map(_norm_app)

    # Determine persona column to use
    persona_key_col = out_persona_u if out_persona_u in df_hr.columns else shd_persona_col_u
    if persona_key_col not in df_hr.columns:
        raise ValueError(f"HR file does not have persona column {out_persona_u} and also not {shd_persona_col_u}.")

    # Normalize BRID in HR
    if brid_u in df_hr.columns:
        df_hr[brid_u] = df_hr[brid_u].astype(str).map(_norm_app)
    else:
        raise ValueError(f"HR file must contain {brid_u} for DOES-HAVE join.")

    # ---------------- 4) Attach sets + compare ----------------
    df_hr["SHD_HAVE_APP_PERM_SET"] = df_hr[persona_key_col].map(shd_have_persona_to_appperm)
    df_hr["SHD_HAVE_APP_PERM_SET"] = df_hr["SHD_HAVE_APP_PERM_SET"].apply(lambda x: x if isinstance(x, set) else set())

    df_hr["DOES_HAVE_APP_PERM_SET"] = df_hr[brid_u].map(does_have_brid_to_appperm)
    df_hr["DOES_HAVE_APP_PERM_SET"] = df_hr["DOES_HAVE_APP_PERM_SET"].apply(lambda x: x if isinstance(x, set) else set())

    comp = df_hr.apply(lambda r: _compare_sets(r["DOES_HAVE_APP_PERM_SET"], r["SHD_HAVE_APP_PERM_SET"]), axis=1)
    df_hr["MATCHED_APP_PERM"] = comp.apply(lambda t: t[0])
    df_hr["MISSING_APP_PERM"] = comp.apply(lambda t: t[1])
    df_hr["EXCESS_APP_PERM"]  = comp.apply(lambda t: t[2])

    # ---------------- 5) output ----------------
    if out_xlsx:
        with pd.ExcelWriter(out_xlsx, engine="openpyxl") as w:
            df_hr.to_excel(w, index=False, sheet_name="HR_APP_PERM_SHD_vs_DOES")
            df_shd.to_excel(w, index=False, sheet_name="SHD_HAVE_RAW")
            df_does.to_excel(w, index=False, sheet_name="DOES_HAVE_RAW")

    return df_hr


def _cli():
    p = argparse.ArgumentParser(description="Compare SHOULD-HAVE vs DOES-HAVE application + permission.")
    p.add_argument("--shd-have", required=True, help="Path to SHOULD-HAVE Excel (multi-sheet).")
    p.add_argument("--hr", required=True, help="Path to HR Excel.")
    p.add_argument("--does-have", required=True, help="Path to DOES-HAVE access export (pipe-delimited by default).")
    p.add_argument("--out", required=True, help="Output Excel path (e.g., output.xlsx).")

    p.add_argument("--shd-sheet-contains", default=None, help='Filter SHOULD-HAVE sheets containing this text (e.g., "COOPAL").')
    p.add_argument("--does-delim", default="|", help='Delimiter for DOES-HAVE file (default "|").')

    p.add_argument("--map-xlsx", default=None, help="Optional costcenter->persona mapping Excel.")
    p.add_argument("--map-sheet", default=None, help="Optional mapping sheet name.")

    args = p.parse_args()

    build_app_perm_should_vs_does_report(
        shd_have_xlsx=args.shd_have,
        hr_xlsx=args.hr,
        does_have_access_file=args.does_have,
        out_xlsx=args.out,
        shd_sheet_filter_contains=args.shd_sheet_contains,
        does_have_delimiter=args.does_delim,
        costcenter_persona_map_xlsx=args.map_xlsx,
        costcenter_persona_map_sheet=args.map_sheet,
    )


if __name__ == "__main__":
    _cli()
