import pandas as pd
from pathlib import Path

def read_file(file_path: Path):
    ext = file_path.suffix.lower()
    encodings_to_try = ['utf-8', 'ISO-8859-1', 'cp1252', 'latin1']
    
    try:
        if ext == '.csv' or ext == '.txt':
            for encoding in encodings_to_try:
                for sep in [',', '\t', '|']:
                    try:
                        df = pd.read_csv(file_path, sep=sep, encoding=encoding)
                        if len(df.columns) > 1:
                            return df
                    except Exception:
                        continue
            # As a fallback, try Python engine without separator
            for encoding in encodings_to_try:
                try:
                    return pd.read_csv(file_path, encoding=encoding, sep=None, engine='python')
                except Exception:
                    continue
        elif ext == '.xlsx':
            return pd.read_excel(file_path)
    except Exception as e:
        print(f"‚ùå Error reading {file_path.name}: {e}")
        return None



def merge_files_to_dataframe(folder_path):
    folder = Path(folder_path)
    all_files = list(folder.glob('*.csv')) + list(folder.glob('*.xlsx')) + list(folder.glob('*.txt'))

    print(f"\nüìÇ Found {len(all_files)} files to process:\n")
    for idx, file in enumerate(all_files, 1):
        print(f"{idx}. {file.name}")

    combined_df = pd.DataFrame()

    for file in all_files:
        df = read_file(file)
        if df is not None:
            df['source_file'] = file.name  # Optional: traceability
            combined_df = pd.concat([combined_df, df], axis=0, ignore_index=True, sort=False)

    return combined_df

# üîÑ Example usage
folder_path = "your/folder/path"  # Replace with your actual path
final_df = merge_files_to_dataframe(folder_path)

print("\n‚úÖ Final merged DataFrame preview:")
print(final_df.head())
print(f"\nüìä Total rows combined: {len(final_df)}")
print(f"üìä Total columns in merged DataFrame: {len(final_df.columns)}")

# Optional: Save to CSV
# final_df.to_csv("merged_output.csv", index=False)



###### only excel




import pandas as pd
from pathlib import Path

def read_excel_file(file_path: Path):
    try:
        df = pd.read_excel(file_path, engine='openpyxl' if file_path.suffix == '.xlsx' else None)
        df['source_file'] = file_path.name  # ‚úÖ Add source file name
        return df
    except Exception as e:
        print(f"‚ùå Error reading {file_path.name}: {e}")
        return None

def merge_excel_files(folder_path):
    folder = Path(folder_path)
    excel_files = list(folder.glob('*.xls')) + list(folder.glob('*.xlsx'))

    print(f"\nüìÇ Found {len(excel_files)} Excel files to process:\n")
    for idx, file in enumerate(excel_files, 1):
        print(f"{idx}. {file.name}")

    combined_df = pd.DataFrame()

    for file in excel_files:
        df = read_excel_file(file)
        if df is not None:
            combined_df = pd.concat([combined_df, df], axis=0, ignore_index=True, sort=False)

    return combined_df

# === Run ===
folder_path = "your/folder/path"  # Change this
final_df = merge_excel_files(folder_path)


#####################################################################


import pandas as pd

# Assuming your dataframe is called df
# Columns include: matched_applications, missing_applications, excess_applications

def flatten_applications(df):
    # Collect exploded DataFrames
    flattened_frames = []
    
    # Define mapping of columns to statuses
    status_map = {
        'matched_applications': 'matched',
        'missing_applications': 'missing',
        'excess_applications': 'excess'
    }
    
    for col, status in status_map.items():
        temp = df.copy()
        
        # Explode so each list element becomes its own row
        temp = temp.explode(col)
        
        # Rename to a unified column
        temp = temp.rename(columns={col: 'applications'})
        
        # Assign the status type
        temp['status'] = status
        
        # Keep only non-null, non-empty applications
        temp = temp[temp['applications'].notna()]
        temp = temp[temp['applications'].astype(str).str.strip() != '']
        
        flattened_frames.append(temp)
    
    # Concatenate all exploded DataFrames
    combined = pd.concat(flattened_frames, ignore_index=True)
    
    # Drop original list columns
    drop_cols = list(status_map.keys())
    cols_to_keep = [col for col in df.columns if col not in drop_cols]
    
    # Final clean dataframe
    combined = combined[cols_to_keep + ['applications', 'status']]
    
    return combined


# Example usage:
# final_df = flatten_applications(df)
# print(final_df.head())

print("\n‚úÖ Final merged Excel DataFrame preview:")
print(final_df.head())
print(f"\nüìä Total rows: {len(final_df)} | Columns: {len(final_df.columns)}")

# final_df.to_csv("merged_excel_output.csv", index=False)
